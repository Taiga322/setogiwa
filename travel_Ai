import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { 
  getFirestore, doc, setDoc, onSnapshot, collection, query, 
  serverTimestamp 
} from 'firebase/firestore'; // whereを削除 (パスでスコープするため不要)

// --- Firebase Configuration & Setup ---
// グローバル変数から設定を読み込む（Canvas環境必須）
const firebaseConfig = typeof __firebase_config !== 'undefined' 
  ? JSON.parse(__firebase_config) 
  : { /* 開発環境向けダミー設定 */ };

const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// API Key (Canvas環境で自動提供されるため、空文字列でOK)
const API_KEY = ""; 
// ★修正1: APIキーを含まないベースURLを定義
const GEMINI_API_BASE_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent";


// Voice Configuration for TTS (TTS機能は今回は含みません)
const SPEAKER_VOICES = {
    'Joe': 'Kore',
    'Jane': 'Puck'
};


// --- Utility Functions ---

/**
 * Exponential backoff for API calls
 */
const fetchWithRetry = async (url, options, retries = 3) => {
  // ★修正2: URLにAPI KEYをクエリパラメータとして追加することで、Canvasでの自動置換を確実にする
  const apiUrl = `${url}?key=${API_KEY}`; 
    
  if (API_KEY === "") {
    console.log("DEBUG: API_KEY is empty. Relying on Canvas runtime injection.");
  }
    
  for (let i = 0; i < retries; i++) {
    try {
      const response = await fetch(apiUrl, options);
      if (response.ok) {
        return response;
      }
      // Retry on certain HTTP error codes (e.g., 5xx)
      if (response.status >= 500 && response.status < 600 && i < retries - 1) {
        const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      // 401, 403, 404 などのエラーの場合はリトライせずに例外を投げる
      throw new Error(`API Request failed with status ${response.status}`);
    } catch (error) {
      if (i === retries - 1) throw error;
      const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
};


// --- React Components ---

/**
 * 旅程の表示と編集を行うコンポーネント
 */
const PlanDisplay = ({ plan, isEditable, onUpdatePlan, isMyPlan }) => {
  const [editingPlan, setEditingPlan] = useState(plan);
  
  // 編集モードを切り替えるハンドラ
  const handleEditChange = (dayIndex, activityIndex, field, value) => {
    const newPlan = JSON.parse(JSON.stringify(editingPlan));
    if (!newPlan.itinerary_json.days) return;

    newPlan.itinerary_json.days[dayIndex].activities[activityIndex][field] = value;
    setEditingPlan(newPlan);
  };
  
  // 変更をFirestoreに保存するハンドラ
  const handleSave = () => {
    onUpdatePlan(editingPlan);
    // window.alert() の代わりにカスタムメッセージを使用
    // alert('プランを保存しました！同行者にも反映されます。'); 
    console.log('プランを保存しました！同行者にも反映されます。');
  };

  useEffect(() => {
    if (plan) {
      setEditingPlan(plan);
    }
  }, [plan]);

  if (!plan || !plan.itinerary_json || !plan.itinerary_json.days) {
    return <div className="text-center p-8 text-gray-500">まだプランがありません。AIに作成を依頼してください。</div>;
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center bg-white p-4 rounded-xl shadow-md">
          <h2 className="text-xl font-bold text-gray-800">
              ✈️ {plan.itinerary_json.destination} の旅 ({plan.itinerary_json.days.length}日間)
          </h2>
          {isEditable && (
            <button 
                onClick={handleSave}
                className="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-full shadow-lg transition duration-200"
            >
                🔄 プランを同期・保存
            </button>
          )}
      </div>

      {editingPlan.itinerary_json.days.map((day, dayIndex) => (
        <div key={dayIndex} className="bg-white p-6 rounded-xl shadow-lg border-t-4 border-indigo-500">
          <h3 className="text-lg font-bold mb-4 text-indigo-700">
            Day {day.day_number}: {day.date}
          </h3>
          <ul className="space-y-4">
            {day.activities.map((activity, activityIndex) => (
              <li key={activityIndex} className="flex items-start space-x-3 p-3 bg-indigo-50 rounded-lg shadow-sm">
                <span className="flex-shrink-0 mt-1 text-indigo-500 text-lg">
                  {activity.spot_name.includes('宿泊') ? '🏨' : activity.spot_name.includes('移動') ? '🚗' : '📍'}
                </span>
                <div className="flex-grow">
                  <div className="font-semibold text-gray-800">
                    {isEditable ? (
                        <input
                            type="text"
                            value={activity.spot_name}
                            onChange={(e) => handleEditChange(dayIndex, activityIndex, 'spot_name', e.target.value)}
                            className="w-full font-bold bg-white border border-gray-300 rounded p-1"
                        />
                    ) : (
                        activity.spot_name
                    )}
                  </div>
                  <div className="text-sm text-gray-600 mt-0.5 flex space-x-2">
                    <span className="font-medium text-indigo-500">
                        {isEditable ? (
                            <input
                                type="text"
                                value={activity.time}
                                onChange={(e) => handleEditChange(dayIndex, activityIndex, 'time', e.target.value)}
                                className="w-16 bg-white border border-gray-300 rounded p-1"
                            />
                        ) : (
                            activity.time
                        )}
                    </span>
                    <span>| 滞在: {activity.duration}分</span>
                  </div>
                  {activity.notes && <p className="text-xs italic text-gray-500 mt-1">{activity.notes}</p>}
                </div>
              </li>
            ))}
          </ul>
        </div>
      ))}
    </div>
  );
};


/**
 * 旅ナカAIチャットコンポーネント
 */
const AIChat = ({ currentPlan, userId }) => {
  const [messages, setMessages] = useState([
    { role: 'ai', text: 'こんにちは！旅の設計士AIです。旅の途中での急な予定変更や、困ったことがあれば何でも聞いてくださいね。' }
  ]);
  const [input, setInput] = useState('');
  const [isTyping, setIsTyping] = useState(false);

  // ユーザーの質問に対するAI応答ロジック
  const getAIResponse = async (userText) => {
    setIsTyping(true);
    
    // 現在の旅の状況をAIに伝えるコンテキスト情報 (重要)
    const currentContext = {
      user_id: userId,
      current_time: new Date().toLocaleTimeString('ja-JP'),
      plan_summary: currentPlan ? JSON.stringify(currentPlan.itinerary_json, null, 2) : 'プランはまだ作成されていません。',
      user_query: userText,
      // 実際には GPS 情報、天気情報などをここに追加する
      simulated_context: {
        location: '沖縄県那覇市の国際通り付近',
        next_plan: currentPlan && currentPlan.itinerary_json.days.length > 0 && currentPlan.itinerary_json.days[0].activities.length > 1 
          ? currentPlan.itinerary_json.days[0].activities[1].spot_name 
          : '未定',
        weather: '快晴'
      }
    };
    
    const systemPrompt = `あなたはユーザーの旅行プランを知っている専門の旅行コンシェルジュAIです。
    ユーザーからの質問に対し、現在の旅程と状況（${currentContext.simulated_context.location}など）に基づいて、具体的で親切なアドバイスをしてください。
    プランに関する質問にはプラン（${currentContext.plan_summary}）の内容を参照し、プランにない質問には一般的な旅行情報や代替案を提供してください。
    会話は日本語で行い、フレンドリーで親切なトーンを維持してください。`;
    
    const userQuery = `現在の状況: ${JSON.stringify(currentContext.simulated_context)}\nユーザーからの質問: ${userText}\n\n旅程: ${currentContext.plan_summary}`;

    const payload = {
        contents: [{ parts: [{ text: userQuery }] }],
        systemInstruction: { parts: [{ text: systemPrompt }] },
    };

    try {
        // AIChat内のAPI呼び出しもBASE URLを使用
        const response = await fetchWithRetry(GEMINI_API_BASE_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        const result = await response.json();
        const aiText = result.candidates?.[0]?.content?.parts?.[0]?.text || "すみません、応答を得ることができませんでした。";

        setMessages(prev => [...prev, { role: 'ai', text: aiText }]);
    } catch (error) {
        console.error("Gemini API Error:", error);
        setMessages(prev => [...prev, { role: 'ai', text: 'ネットワークエラーが発生しました。しばらくしてからもう一度お試しください。（エラーコード: 401の可能性）' }]);
    } finally {
        setIsTyping(false);
    }
  };

  const handleSend = () => {
    if (!input.trim() || isTyping) return;
    
    const userText = input;
    setMessages(prev => [...prev, { role: 'user', text: userText }]);
    setInput('');
    
    getAIResponse(userText);
  };

  return (
    <div className="flex flex-col h-full bg-white rounded-xl shadow-2xl p-4">
      <h2 className="text-xl font-bold mb-3 text-indigo-700 border-b pb-2">🤖 旅ナカ AIコンシェルジュ</h2>
      <div className="flex-grow overflow-y-auto space-y-4 p-2 custom-scrollbar">
        {messages.map((msg, index) => (
          <div key={index} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
            <div className={`max-w-[80%] p-3 rounded-2xl shadow-md ${
              msg.role === 'user' 
                ? 'bg-indigo-500 text-white rounded-br-none' 
                : 'bg-gray-100 text-gray-800 rounded-tl-none'
            }`}>
              {msg.text}
            </div>
          </div>
        ))}
        {isTyping && (
             <div className="flex justify-start">
                <div className="max-w-[80%] p-3 rounded-2xl shadow-md bg-gray-100 text-gray-800 rounded-tl-none italic text-sm">
                   AIが考え中です...
                </div>
            </div>
        )}
      </div>
      <div className="mt-4 flex space-x-2">
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          onKeyDown={(e) => e.key === 'Enter' && handleSend()}
          placeholder="AIに旅の相談をする..."
          className="flex-grow p-3 border border-gray-300 rounded-xl focus:ring-2 focus:ring-indigo-500 transition duration-150"
          disabled={isTyping}
        />
        <button
          onClick={handleSend}
          className="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-5 rounded-xl shadow-lg transition duration-200 disabled:opacity-50"
          disabled={!input.trim() || isTyping}
        >
          送信
        </button>
      </div>
    </div>
  );
};


/**
 * プラン生成フォームコンポーネント
 */
const PlanGeneratorForm = ({ setPlanData, auth }) => { 
  const [step, setStep] = useState(1);
  const [theme, setTheme] = useState('');
  const [destination, setDestination] = useState('');
  const [destinationCandidates, setDestinationCandidates] = useState([]);
  const [themeText, setThemeText] = useState('');
  const [loading, setLoading] = useState(false);
  const [errorMsg, setErrorMsg] = useState('');
  
  const THEME_OPTIONS = [
      { id: 'relax', label: '🏖️ 癒やし・リラックス', prompt: '温泉、ビーチ、自然景観を巡り、心身ともにリフレッシュできる旅' },
      { id: 'gourmet', label: '🍣 グルメ・食べ歩き', prompt: '地元の市場、ミシュラン、隠れた名店など食を堪能する旅' },
      { id: 'active', label: '🏄 アクティブ・体験', prompt: 'ハイキング、マリンスポーツ、文化体験などアクティビティ中心の旅' },
      { id: 'culture', label: '🏯 歴史・文化探訪', prompt: '世界遺産、美術館、歴史的な街並みを深く学ぶ旅' },
  ];

  // Step 2: テーマに基づいた旅先候補をAIに生成させる
  const fetchDestinationCandidates = async () => {
    if (!theme) return;
    setLoading(true);
    setErrorMsg('');
    setDestinationCandidates([]);
    setDestination(''); // 候補が変わるのでリセット

    const selectedTheme = THEME_OPTIONS.find(o => o.id === theme);
    if (!selectedTheme) return;

    const prompt = `テーマ「${selectedTheme.label}: ${selectedTheme.prompt}」に最適な日本の旅行先を5つ提案してください。
    【重要】以下のJSONスキーマに従い、旅行先名（日本語）と簡単な紹介（一文）のリストをJSON形式でのみ出力してください。`;

    const jsonSchema = {
        type: "array",
        items: {
            type: "object",
            properties: {
                name: { type: "string" },
                description: { type: "string" }
            },
            required: ["name", "description"]
        }
    };

    const payload = {
        contents: [{ parts: [{ text: prompt }] }],
        generationConfig: {
            responseMimeType: "application/json",
            responseSchema: jsonSchema
        }
    };

    try {
        const response = await fetchWithRetry(GEMINI_API_BASE_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        const result = await response.json();
        const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if (jsonText) {
             const candidates = JSON.parse(jsonText);
             // JSONが配列またはオブジェクトであることをチェックし、リストとして設定
             setDestinationCandidates(Array.isArray(candidates) ? candidates : [candidates].filter(c => c.name));
        } else {
             // 応答なしの場合のフォールバック
             setErrorMsg('AIから有効な応答が得られませんでした。テーマを変えて再度お試しください。');
             setDestinationCandidates([]);
        }

        setStep(2); // 候補表示ステップへ
    } catch (error) {
        console.error("候補生成エラー:", error);
        
        // ★修正3: 401エラーの場合に特別なメッセージを表示
        if (error.message.includes('401')) {
             setErrorMsg(`AI接続エラーが発生しました（認証失敗）。キャンバス環境の認証キー設定を確認してください。`);
        } else {
             setErrorMsg(`AI接続エラーが発生しました。認証キーまたはネットワークを確認してください。(${error.message})`);
        }
        
        // エラー発生時のフォールバックとしてダミーデータを設定 (動作確認用)
        setDestinationCandidates([
            { name: '沖縄 (ダミー)', description: 'AI接続エラー時の代替候補です。' },
            { name: '京都 (ダミー)', description: 'AI接続エラー時の代替候補です。' }
        ]);
        setStep(2); 
    } finally {
        setLoading(false);
    }
  };


  // Step 3: 最終的なプランをAIに生成させる
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (loading) return;
    setLoading(true);
    setErrorMsg('');

    const authenticatedUid = auth?.currentUser?.uid;
    if (!authenticatedUid) {
        console.log(`プランの保存には認証が必要です。アプリをリロードしてください。`);
        setLoading(false);
        setErrorMsg('認証エラー: プランを保存できません。');
        return;
    }
    
    const selectedTheme = THEME_OPTIONS.find(o => o.id === theme);

    const prompt = `あなたはプロの旅行プランナーです。以下の情報に基づき、実行可能な3日間の旅行プランをJSON形式でのみ出力してください。
    - 目的地: ${destination}
    - 旅のテーマ: ${selectedTheme ? selectedTheme.label : '未設定'}
    - ユーザーの要望（自由入力）: ${themeText}
    - ユーザーの傾向: スタイルはリラックス、予算は中〜高、食事は海鮮を好む。
    - 日程: Day 1 から Day 3 まで。

    【重要】以下のJSONスキーマに従い、回答してください。
    `;

    // JSONスキーマ定義 (AIが出力すべき構造を強制する) - 変更なし
    const jsonSchema = {
        type: "object",
        properties: {
            plan_id: { type: "string" },
            destination: { type: "string" },
            days: {
                type: "array",
                items: {
                    type: "object",
                    properties: {
                        day_number: { type: "integer" },
                        date: { type: "string", description: "例: 10月1日" },
                        activities: {
                            type: "array",
                            items: {
                                type: "object",
                                properties: {
                                    time: { type: "string", description: "例: 9:00" },
                                    spot_name: { type: "string" },
                                    duration: { type: "integer", description: "滞在時間（分）" },
                                    notes: { type: "string", description: "移動手段や予約情報などのメモ" }
                                }
                            }
                        }
                    }
                }
            }
        },
        required: ["plan_id", "destination", "days"]
    };

    const payload = {
        contents: [{ parts: [{ text: prompt }] }],
        generationConfig: {
            responseMimeType: "application/json",
            responseSchema: jsonSchema
        }
    };

    try {
        const response = await fetchWithRetry(GEMINI_API_BASE_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        const result = await response.json();
        
        const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
        if (!jsonText) {
             setErrorMsg("AIから有効なJSON応答が得られませんでした。");
             return;
        }
        
        const parsedPlan = JSON.parse(jsonText);
        
        // Firestoreに保存
        const newPlanId = doc(collection(getFirestore(initializeApp(firebaseConfig)), `artifacts/${appId}/users/${authenticatedUid}/travel_plans`)).id;

        const planToSave = {
            id: newPlanId,
            ownerId: authenticatedUid,
            isPublic: false, 
            createdAt: serverTimestamp(),
            itinerary_json: parsedPlan,
            plan_name: `${parsedPlan.destination}の旅`
        };
        
        const db = getFirestore(initializeApp(firebaseConfig));
        const docRef = doc(db, `artifacts/${appId}/users/${authenticatedUid}/travel_plans`, newPlanId);
        await setDoc(docRef, planToSave);
        
        setPlanData(planToSave); 
        setStep(4); // 完了ステップへ
        console.log("プランが生成され、保存されました！");

    } catch (error) {
        console.error("プラン生成エラー:", error);
        
        // ★修正4: 401エラーの場合に特別なメッセージを表示
        if (error.message.includes('401')) {
            setErrorMsg(`プラン生成エラー（認証失敗）。キャンバス環境の認証キー設定を確認してください。`);
        } else {
            setErrorMsg(`プラン生成エラー: AI接続またはJSONパースに失敗しました。詳細: ${error.message}`);
        }
    } finally {
        setLoading(false);
    }
  };


  // --- Step 1 UI: テーマ選択 ---
  const renderStep1 = () => (
    <div className="space-y-4">
        <h3 className="text-lg font-bold text-indigo-700">ステップ 1/3: 旅のテーマを選ぶ</h3>
        <p className="text-sm text-gray-600">まずは「どんな旅にしたいか」を直感で選んでください。</p>
        <div className="grid grid-cols-2 gap-3">
            {THEME_OPTIONS.map(opt => (
                <button
                    key={opt.id}
                    onClick={() => setTheme(opt.id)}
                    className={`p-4 rounded-xl text-center shadow-md transition duration-200 
                        ${theme === opt.id 
                            ? 'bg-indigo-500 text-white ring-4 ring-indigo-300' 
                            : 'bg-gray-100 hover:bg-indigo-50 border border-gray-300'}`
                    }
                >
                    <span className="font-semibold">{opt.label}</span>
                </button>
            ))}
        </div>
        <button
            onClick={fetchDestinationCandidates}
            disabled={!theme || loading}
            className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-xl transition disabled:opacity-50 flex items-center justify-center space-x-2"
        >
            {loading ? 
                <span className="animate-spin">🌀</span> : 
                <span>次へ: 旅先候補を見る</span>
            }
        </button>
    </div>
  );

  // --- Step 2 UI: 旅先選択 ---
  const renderStep2 = () => (
    <div className="space-y-4">
        <h3 className="text-lg font-bold text-indigo-700">ステップ 2/3: おすすめの旅先を選ぶ</h3>
        <p className="text-sm text-gray-600">選択したテーマに最適な旅先候補です。一つ選んでください。</p>
        
        {/* エラーメッセージ表示 */}
        {errorMsg && (
            <div className="bg-red-100 p-3 rounded-lg text-red-700 text-sm border border-red-300">
                ⚠️ エラーが発生しました: {errorMsg}
            </div>
        )}

        <div className="space-y-3 max-h-60 overflow-y-auto custom-scrollbar p-1">
            {destinationCandidates.length > 0 ? (
                destinationCandidates.map((candidate, index) => (
                    <button
                        key={index}
                        onClick={() => setDestination(candidate.name)}
                        className={`w-full text-left p-4 rounded-xl border transition duration-200 
                            ${destination === candidate.name 
                                ? 'bg-green-500 text-white ring-4 ring-green-300' 
                                : 'bg-white hover:bg-green-50 border-gray-300'}`
                        }
                    >
                        <span className="font-bold">{candidate.name}</span>
                        <p className="text-xs mt-1 italic opacity-80">{candidate.description}</p>
                    </button>
                ))
            ) : (
                <p className="text-gray-500 text-center py-4">候補が生成されませんでした。テーマを再選択してください。</p>
            )}
        </div>
        <button
            onClick={() => setStep(3)}
            disabled={!destination || destinationCandidates.length === 0}
            className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-xl transition disabled:opacity-50"
        >
            最終調整へ進む
        </button>
        <button
            onClick={() => { setStep(1); setErrorMsg(''); setDestination(''); }}
            className="w-full text-sm text-gray-500 hover:text-indigo-500 pt-1"
        >
            テーマを再選択する
        </button>
    </div>
  );

  // --- Step 3 UI: 最終リクエスト入力と生成 ---
  const renderStep3 = () => (
    <form onSubmit={handleSubmit} className="space-y-4">
        <h3 className="text-lg font-bold text-indigo-700">ステップ 3/3: 最終調整と生成</h3>
        
        {/* エラーメッセージ表示 */}
        {errorMsg && (
            <div className="bg-red-100 p-3 rounded-lg text-red-700 text-sm border border-red-300">
                ⚠️ エラーが発生しました: {errorMsg}
            </div>
        )}
        
        <div className="bg-green-100 p-3 rounded-lg border border-green-300">
            <p className="text-sm font-semibold text-green-700">決定内容</p>
            <p className="text-xs">テーマ: {THEME_OPTIONS.find(o => o.id === theme)?.label}</p>
            <p className="text-xs">旅先: {destination}</p>
        </div>

        <div>
            <label className="block text-sm font-medium text-gray-700">自由入力（曖昧なリクエスト）</label>
            <textarea
                value={themeText}
                onChange={(e) => setThemeText(e.target.value)}
                placeholder="例: ビーチで癒やされたい、おしゃれなカフェ巡りと地元グルメを楽しみたい"
                rows="3"
                className="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150"
                required
            />
            <p className="text-xs text-gray-500 mt-1">「テーマ」と「旅先」に基づき、AIが旅程を生成します。</p>
        </div>
        
        <button
          type="submit"
          className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-xl shadow-lg transition duration-200 disabled:opacity-50 flex items-center justify-center"
          disabled={loading}
        >
          {loading ? (
            <>
              <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              AIが完璧なプランを設計中...
            </>
          ) : (
            '🚀 完璧な旅程をAIに生成してもらう'
          )}
        </button>
        <button
            onClick={() => setStep(2)}
            className="w-full text-sm text-gray-500 hover:text-indigo-500 pt-1"
            type="button"
        >
            旅先を再選択する
        </button>
    </form>
  );
  
  // --- Step 4 UI: 完了と次へ ---
  const renderStep4 = () => (
    <div className="space-y-6 p-6 text-center bg-green-50 rounded-xl border border-green-300">
        <h3 className="text-2xl font-bold text-green-700">✅ プラン生成完了！</h3>
        <p className="text-gray-700">右側の編集エリアに新しい旅程が反映されました。</p>
        <p className="text-sm text-gray-600">さあ、プランを確認・編集して、旅ナカAIチャットで相談してみましょう。</p>
        <button
            onClick={() => { setStep(1); setDestination(''); setTheme(''); setThemeText(''); setErrorMsg(''); }}
            className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-xl transition"
        >
            新しいプランを作成する
        </button>
    </div>
  );


  // --- メインレンダリング ---
  return (
    <div className="bg-white p-6 rounded-xl shadow-xl">
        <div className="text-lg font-bold text-gray-800 mb-4">
            <span className="text-indigo-600">ステップ {step}</span> / 旅のプランニング
        </div>
        {step === 1 && renderStep1()}
        {step === 2 && renderStep2()}
        {step === 3 && renderStep3()}
        {step === 4 && renderStep4()}
    </div>
  );
};


/**
 * メインアプリケーションコンポーネント
 */
const App = () => {
  const [db, setDb] = useState(null);
  const [auth, setAuth] = useState(null);
  const [userId, setUserId] = useState(null);
  const [isAuthReady, setIsAuthReady] = useState(false);
  const [currentPlan, setCurrentPlan] = useState(null);
  const [plans, setPlans] = useState([]);

  // 1. Firebase初期化と認証
  useEffect(() => {
    const app = initializeApp(firebaseConfig);
    const firestore = getFirestore(app);
    const authInstance = getAuth(app);
    setDb(firestore);
    setAuth(authInstance);

    // 認証処理
    const handleAuth = async () => {
        try {
            if (initialAuthToken) {
                await signInWithCustomToken(authInstance, initialAuthToken);
            } else {
                await signInAnonymously(authInstance);
            }
        } catch (error) {
            console.error("Firebase Auth Error:", error);
        }
    };
    handleAuth();

    // 認証状態の変更を監視
    const unsubscribe = onAuthStateChanged(authInstance, (user) => {
        if (user) {
            setUserId(user.uid); // 認証済みUID
        } else {
            // 認証が確認できない場合でも、UI表示用にランダムなIDを使用
            setUserId(crypto.randomUUID());
        }
        setIsAuthReady(true);
    });

    return () => unsubscribe();
  }, []);
  
  // 2. プランのリアルタイムリスナー (onSnapshot)
  useEffect(() => {
    if (!db || !auth || !isAuthReady) return; 

    // 認証済みUIDが取得できるまでリスナーを実行しない
    const authenticatedUid = auth.currentUser?.uid;
    if (!authenticatedUid) {
        console.log("Firestore: User not fully authenticated yet, skipping listener.");
        setPlans([]);
        setCurrentPlan(null);
        return; 
    }

    // コレクションパスをユーザー専用のプライベートパスに変更
    const plansCollectionRef = collection(db, `artifacts/${appId}/users/${authenticatedUid}/travel_plans`);
    const q = query(plansCollectionRef); 

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const fetchedPlans = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      setPlans(fetchedPlans);
      // NOTE: プラン生成時にsetCurrentPlanが直接呼ばれるため、このロジックは
      // ユーザーが手動でリロードしたり、過去のプランを復元する場合にのみ重要になる
      if (fetchedPlans.length > 0 && !currentPlan) {
        // 初回ロード時に最新のプランをセット
        // 実際には createdAt や updatedAt でソートすべきだが、ここでは最後の要素を最新とする
        setCurrentPlan(fetchedPlans[fetchedPlans.length - 1]);
      }
    }, (error) => {
      console.error("Firestore error:", error);
    });

    return () => unsubscribe();
  }, [db, auth, isAuthReady, appId, currentPlan]);
  
  // 3. プランの更新ハンドラ
  const handleUpdatePlan = useCallback(async (updatedPlan) => {
    if (!db || !updatedPlan || !updatedPlan.id || !auth) {
        console.log("Cannot update plan: DB or Auth not ready.");
        return;
    }
    
    // 認証済みUIDが取得できるかチェック
    const authenticatedUid = auth.currentUser?.uid;
    if (!authenticatedUid) {
        console.log("Cannot update plan: User not authenticated.");
        return;
    }
    
    try {
        // ドキュメント参照パスに認証済みUIDを使用
        const planDocRef = doc(db, `artifacts/${appId}/users/${authenticatedUid}/travel_plans`, updatedPlan.id);
        
        await setDoc(planDocRef, {
            ...updatedPlan,
            updatedAt: serverTimestamp() // 更新日時を記録
        }, { merge: true }); // マージして更新
        
        // 更新後、即座にUIに反映
        setCurrentPlan(updatedPlan);
        
    } catch (error) {
        console.error("プラン更新に失敗しました:", error);
        console.log('プランの同期に失敗しました。');
    }
  }, [db, auth, appId]); 
  
  const currentPlanId = currentPlan ? currentPlan.id : 'N/A';
  
  if (!isAuthReady) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <p className="text-xl text-indigo-600">アプリを初期化中...</p>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 p-6 font-sans">
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background-color: #9ca3af; border-radius: 4px; }
      `}</style>
      
      <header className="text-center mb-10">
        <h1 className="text-4xl font-extrabold text-indigo-700">旅の設計士 AIプランナー</h1>
        <p className="text-gray-600 mt-2">テーマ選択から始める、完璧な旅ナカサポート。</p>
        <p className="text-xs text-gray-400 mt-1">あなたのユーザーID (同行者と共有): <span className="font-mono text-indigo-500">{userId}</span></p>
        {currentPlan && <p className="text-xs text-gray-400 mt-1">現在のプランID: <span className="font-mono text-indigo-500">{currentPlanId}</span></p>}
      </header>
      
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
        
        {/* 左サイドバー: プラン生成とチャット */}
        <div className="lg:col-span-1 space-y-8">
          <PlanGeneratorForm setPlanData={setCurrentPlan} auth={auth} /> {/* authを渡す */}
          
          <div className="h-[400px]">
            <AIChat currentPlan={currentPlan} userId={userId} />
          </div>
        </div>
        
        {/* メインエリア: プラン表示と編集 */}
        <div className="lg:col-span-2">
          <PlanDisplay 
            plan={currentPlan} 
            isEditable={true} 
            onUpdatePlan={handleUpdatePlan} 
            isMyPlan={true} 
          />
        </div>
      </div>
      
    </div>
  );
};

export default App;
